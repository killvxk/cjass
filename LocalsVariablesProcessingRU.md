# Локальные переменные в cJass #

## Свободное объявление локальных переменных ##

В JASS2 все локальные переменные должны быть объявлены сразу после начала функции, в которой они используются. Используя cJass, вы можете объявлять локальные переменные в любом месте тела функции.

```
nothing foo () {
    DoNothing ()
    int bar = 0
}
```

Парсер перенесет в начало функции объявления всех локальных переменных. Так, как в JASS2 вместе с объявлением, переменная может быть инициализирована, cJass анализирует присваемое ей значение перед переносом в начало. Инициализация переменных явными значениями однозначно переносится вместе с соответствуюшими переменными. Остальные строки инициализации переменных остаются на местах объявления, например:

```
nothing foo () {
      DoNothing()
      integer i = 0              // объявление будет перенесено целиком,
      location l = Location(0,0) // эта переменная будет инициализирована здесь
}
// --->
function foo takes nothing returns nothing
    local integer i = 0
    local location l
    call DoNothing ()
    set l = Location (0,0)
endfunction
```

Локальные переменные, как и любые другие переменные одного типа в cJass можно объявлять в одной строке, разделяя запятыми:

```
int i = 7, j, k
// --->
local integer i = 7
local integer j
local integer k
```

## Ограничение области видимости локальной переменной, объявленной в блоке ##

В cJass область видимости локальной переменной ограничена блоком (например `if`, `for` или `loop`), где эта переменная была объявлена. С точки зрения пользователя переменная создается при входе в блок точно также, как создается обычная локальная переменная при входе в функцию; не инициализированная переменная содержит мусор; переменная удаляется после выхода из блока.

```
nothing fx () {
    int foo // мы можем обратиться к этой переменной из любой точки в функции
    if (b) {
        int bar
    }
    bar ++ // ошибка, мы не можем обратиться к этой переменной вне блока
    for (int bar = 0; bar < 16; bar++) { // мы можем объявить переменную с таким же именем
                                         // в другом блоке и использовать ее
        DoSomething ()
    }
    for (int i = 0; i < 16; i++) {
        for (int i = 0; i < 16; i++) { // ошибка, "затемнение" переменных не поддерживается
            Spam (i)                   // в противном случае это бы провоцировало программиста
                                       // допускать ошибки, подобные этой
        }
    }
}
```

Объявление переменной в теле цикла с присвоением ей значения будет интерпретировано как однократное создание переменной и присвоение ей указанного значения в каждой итерации цикла (непонимание этого принципа может приводить к ошибкам):

```
nothing fx () {
    loop {
        int i = 0 //
    }
}
// --->
function fx takes nothing returns nothing
    local int i
    loop
        set i = 0
    endloop
endfunction
```

Цикл `for` содержит объявление и инициализацию переменной в своем заголовке, поэтому при его использование объявление (если оно есть) и инициализация переменной происходит непосредственно перед телом цикла.

### Принцип действия ###

cJass переименовывает все локальные переменные, объявленные в блоке (их имена имеют вид cjlocgn_). В каждой функции создается минимальный набор необходимых переменных:_

```
nothing fx () {
    if (b) {
        int a = 0
    }
    if (b) {
        int b = 1
        for (int c = 2; c < 256; c++) {
            b += 2
        }
    }
}
// --->
function fx takes nothing returns nothing
    local int cjlocgn_00000000
    local int cjlocgn_00000001
    if (b) then
        set cjlocgn_00000000 = 0
    endif
    if (b) then
        set cjlocgn_00000000 = 1 // повторное использовать переменной
        if (cjlocgn_00000000) then
            set cjlocgn_00000001 = 2
        endif
    endif
endfunction
```

### Обнуление переменных ###

Фактически, программист не знает (и ему не зачем знать) будет ли, и если да - то как переменная использована после какой либо области кода:

```
// ...
if (expr) {
    unit u = GetSomeUnit ()
    DoSomething (u)
    // ...
}
// ...
```

При этом конечно можно обнулить переменную вручную: `u = null`, однако если переменная будет использована дальше, то данное действие становится бессмысленный. Конечно, в лишнем обнулении нет ничего страшного. Тем не менее это "лишняя" работа. Для ее избежания рекомендуется использовать  [автоматическое обнуление локальных переменных](http://code.google.com/p/cjass/wiki/LocalsVariablesFlushingRU#Автоматическое_обнуление) - cJass, зная, как и где какая переменная используется будет генерировать более чистый код.

### Анонимный блок vblock ###

Анонимный блок используется для разграничения области видимости локальных переменных.

```
#define RegOnRegEntry (code, xMin, yMin, xMax, yMax) = {
    vblock {
        rect r = Rect (xMin, yMin, xMax, yMax)
        region rg = CreateRegion ()
        RegionAddRect (rg, r)
        trigger t = CreateTrigger ()
        TriggerAddAction (t, code)
        TriggerRegisterEnterRegion (t, rg, null)
    }
}
```

Без анонимного блока создание подобного макроса было бы заметно усложнено.

## Статические переменные ##

В cJass внутри функции может быть объявлена статическая переменная.

```
nothing foo () {
    static int bar = 0
}
```

Статические переменные создаются в момент инициализации кода, поэтому в случаи объявления с присвоением нельзя использовать еще не существующие объекты, например локальные переменные. Статические переменные не удаляются при выходе из функции, а при повторном входе не создаются снова. Ввиду этого статические переменные не нуждаются в обнулении.

Область видимости статической переменной - все тело функции.

```
nothing fx (int foo) {
    static int callCounter = 0 // счетчик вызова функции
    callCounter ++             // увеличиваем его значение
    static int bar
    if (foo > bar) {
        bar = foo
    }
}
```

В настоящий момент нельзя получить доступ к статической переменной из анонимной функции, однако в следующих версиях такая возможность будет добавлена.